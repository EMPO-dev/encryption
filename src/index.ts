import * as crypto from 'crypto'
import * as argon2 from 'argon2'

type RandomByteTypes = 'iv' | 'salt'
type RandomByteEncodingTypes = 'base64'
interface RandomByteOptions {
  type: RandomByteTypes
  encoding?: RandomByteEncodingTypes
}

/**
 * @param {object} options Options to generate random key
 */
export const generateRandomBytes = (
  options: RandomByteOptions
): Buffer | string => {
  const { type, encoding } = options
  if (!type) throw new Error('type not defined.')

  const getSize = (type: string): number => {
    // returns a buffer containing raw bytes.
    switch (type) {
      // 16 raw bytes for IV (For cryptographic encryptions)
      case 'iv':
        return 16
      // 24 raw bytes for Salt (For secure hash functions and users)
      case 'salt':
        return 24
      default:
        throw new Error('unaccepted type.')
    }
  }
  // buffer size
  const size: number = getSize(type)
  const buffer = crypto.randomBytes(size)

  switch (encoding) {
    case 'base64':
      // returns Base64 encoded value
      return buffer.toString('base64')
  }

  return buffer
}

export class AES {
  readonly _salt: string

  constructor(pepper: string) {
    this._salt = pepper
  }

  /**
   * @description A basic API for block cipher encryption using AES256-GCM.
   * @param {string} text Plaintext
   */
  encrypt = (text: string): string => {

    // use AES256-GCM
    const algorithm = 'aes-256-gcm'
    const iv = generateRandomBytes({ type: 'iv' }) as Buffer
    const cipher = crypto.createCipheriv(algorithm, this._salt, iv)

    // encrypt the given text
    const encrypted = Buffer.concat([
      cipher.update(`${text}`, 'utf8'),
      cipher.final()
    ])
    const tag = cipher.getAuthTag()

    // returns Base64 encoded value of [IV + Tag + encrypted]
    return Buffer.concat([iv, tag, encrypted]).toString('base64')
  }

  /**
   * @description A basic API for block cipher decryption using AES256-GCM.
   * @param {string} encrypted [IV + Tag + encrypted]
   */
  decrypt = (encrypted: string): string => {
    const buffers = Buffer.from(`${encrypted}`, 'base64')

    // convert data to buffers
    const iv = buffers.slice(0, 16)
    const tag = buffers.slice(16, 32)
    const text = buffers.slice(32, 40)

    // use AES256-GCM
    const algorithm = 'aes-256-gcm'
    const decipher = crypto.createDecipheriv(algorithm, this._salt, iv)
    decipher.setAuthTag(tag)

    // decrypt the given text
    const decrypted =
      decipher.update(text, 'binary', 'utf8') + decipher.final('utf8')

    // returns UTF-8 encoded value
    return decrypted
  }
}

export class SHA {
  private _pepper: string;

  constructor(pepper: string) {
    this._pepper = pepper;
  }

  /**
   * @description A secure hash function using HMAC-SHA256
   * @param {string} text Plaintext
   */
  encrypt = (text: string): string => {
    const encoding = "base64";
    const algorithm = "sha256";

    // returns Base64 encoded value
    return crypto
      .createHash(algorithm)
      .update(text)
      .digest(encoding);
  };
}

export class SHAKE256 {

  /**
   * @description A secure hash function using SHAKE256 (SHA-3)
   * @param {string} text Plaintext
   */
  encrypt = (text: string): string => {
    const encoding = "base64";
    const algorithm = "shake256";

    // returns Base64 encoded value
    return crypto
      .createHash(algorithm)
      .update(text)
      .digest(encoding);
  };
}

export class Argon2 {
  readonly _pepper: string;
  readonly _salt: string;

  private readonly SHA: SHA;

  constructor(pepper: string, salt: string) {
    this._pepper = pepper;
    this._salt = salt;

    this.SHA = new SHA(pepper);
  }

  /**
   * @description A key derivation function using Argon2
   * @param {string} text Plaintext
   */
  encrypt = (text: string): Promise<string> => {
    if (!this._salt) {
      throw new Error("salt is not defined.");
    }

    const value = text + this._salt;
    const pre_hash = this.SHA.encrypt(value);

    // outputs hashed value
    return argon2.hash(pre_hash);
  };

  /**
   * @description A verification function with input text and Argon2 hashed value
   * @param {string} hash Hash generated by argonEncrypt()
   * @param {string} text Plaintext for verification
   */
  match = (hash: string, text: string): Promise<boolean> => {
    const value = text + this._salt;
    const pre_raw = this.SHA.encrypt(value);

    // verify hashed value
    return argon2.verify(hash, pre_raw);
  };
}
