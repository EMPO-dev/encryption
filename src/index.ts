import * as crypto from 'crypto'
import * as argon2 from 'argon2'

type RandomByteTypes = 'iv' | 'salt'
type RandomByteEncodingTypes = 'base64'
interface RandomByteOptions {
  type: RandomByteTypes
  encoding?: RandomByteEncodingTypes
}

/**
 * @param {object} options Options to generate random key
 */
export const generateRandomBytes = (
  options: RandomByteOptions
): Buffer | string => {
  const { type, encoding } = options
  if (!type) throw new Error('type not defined.')

  const getSize = (type: string): number => {
    // returns a buffer containing raw bytes.
    switch (type) {

      // 16 raw bytes for IV (For cryptographic encryptions)
      case 'iv':
        return 16

      // 24 raw bytes for Salt (For secure hash functions and users)
      case 'salt':
        return 24
      default:
        throw new Error('unaccepted type.')
    }
  }

  // buffer size
  const size: number = getSize(type)
  const buffer = crypto.randomBytes(size)

  switch (encoding) {
    case 'base64':
      // returns Base64 encoded value
      return buffer.toString('base64')
  }

  return buffer
}

export class AES {
  readonly secret: string

  constructor(secret: string) {
    this.secret = secret
  }
  
  // derived encryption key length: 32 bytes
  getKey = (salt: Buffer): Buffer => {
    return crypto.pbkdf2Sync(this.secret, salt, 100000, 32, 'sha512')
  }

  /**
   * @description A basic API for block cipher encryption using AES256-GCM.
   * @param {string} plainText Plaintext
   */
  encrypt = (plainText: string): string => {
    const algorithm = 'aes-256-gcm'
    // IV for AES GCM XOR Init
    const iv = crypto.randomBytes(16)

    // Salt for derivation key
    const salt = crypto.randomBytes(64)
    
    const key = this.getKey(salt)
    const cipher = crypto.createCipheriv(algorithm, key, iv)

    // encrypt the given text
    const encrypted = Buffer.concat([
      cipher.update(`${plainText}`, 'utf8'),
      cipher.final()
    ])
    
    // extract the auth tag (16 bytes)
    const tag = cipher.getAuthTag()

    // generate base64 encoded output (N-96 bytes)
    return Buffer.concat([salt, iv, tag, encrypted]).toString('base64')
  }

  /**
   * @description A basic API for block cipher decryption using AES256-GCM.
   * @param {string} cipherText Encrypted text
   */
  decrypt = (cipherText: string): string => {
    // base64 decoding
    const bufferData = Buffer.from(`${cipherText}`, 'base64')

    // convert data to buffers
    const salt = bufferData.slice(0, 64)
    const iv = bufferData.slice(64, 80)
    const tag = bufferData.slice(80, 96)
    const encrypted = bufferData.slice(96)

    const algorithm = 'aes-256-gcm'

    // derive key
    const key = this.getKey(salt)
    const decipher = crypto.createDecipheriv(algorithm, key, iv)

    decipher.setAuthTag(tag)

    // generate utf8 encoded output
    return decipher.update(encrypted) + decipher.final('utf8')
  }
}

export class SHA {
  private _pepper: string

  constructor(pepper: string) {
    this._pepper = pepper
  }

  /**
   * @description A secure hash function using HMAC-SHA256
   * @param {string} plainText Plaintext
   */
  encrypt = (plainText: string): string => {
    const encoding = 'base64'
    const algorithm = 'sha256'

    // generate base64 encoded output
    return crypto
      .createHmac(algorithm, this._pepper)
      .update(plainText)
      .digest(encoding)
  }
}

export class SHAKE256 {

  /**
   * @description A secure hash function using SHAKE256 (SHA-3)
   * @param {string} plainText Plaintext
   */
  encrypt = (plainText: string): string => {
    const encoding = 'base64'
    const algorithm = 'shake256'

    // generate base64 encoded output
    return crypto
      .createHash(algorithm)
      .update(plainText)
      .digest(encoding)
  }
}

export class Argon2 {
  readonly _pepper: string
  readonly _salt: string

  private readonly SHA: SHA

  constructor(pepper: string, salt: string) {
    this._pepper = pepper
    this._salt = salt

    this.SHA = new SHA(pepper)
  }

  /**
   * @description A key derivation function using Argon2
   * @param {string} plainText Plaintext
   */
  encrypt = (plainText: string): Promise<string> => {
    if (!this._salt) {
      throw new Error("salt is not defined.")
    }

    const value = plainText + this._salt
    const pre_hash = this.SHA.encrypt(value)

    // generate hashed output
    return argon2.hash(pre_hash)
  }

  /**
   * @description A verification function with input text and Argon2 hashed value
   * @param {string} hash Hash generated by argonEncrypt()
   * @param {string} plainText Plaintext for verification
   */
  match = (hash: string, plainText: string): Promise<boolean> => {
    const value = plainText + this._salt
    const pre_raw = this.SHA.encrypt(value)

    // verify hashed value with input text
    return argon2.verify(hash, pre_raw)
  }
}
